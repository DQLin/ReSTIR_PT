# FLIP GitHub repository: https://github.com/NVlabs/flip.

# A render graph that creates a reference image and a test image
# and compares them using LDR-FLIP. The reference is an accumulation
# of 1 spp path traced images while the test is generated by
# rendering 1 spp path traced images using ReSTIR, followed
# by denoising with the NRD denoiser and DLSS.
def render_graph_LDRFLIPDemo():
    g = RenderGraph("LDRFLIPDemo")

    loadRenderPassLibrary("GBuffer.dll")
    loadRenderPassLibrary("InlinePathTracer.dll")
    loadRenderPassLibrary("AccumulatePass.dll")
    loadRenderPassLibrary("NRDPass.dll")
    loadRenderPassLibrary("ReLAX.dll")
    loadRenderPassLibrary("ToneMapper.dll")
    loadRenderPassLibrary("DLSSPass.dll")
    loadRenderPassLibrary("FLIPPass.dll")

    GBufferRT = createPass("GBufferRT", {'samplePattern': SamplePattern.Center, 'texLOD': TexLODMode.RayCones})
    g.addPass(GBufferRT, "GBufferRT")

    ######################################################################################################
    #################### Reference graph (accumulated inline path tracer results) ########################
    ######################################################################################################
    InlinePathTracerReference = createPass("InlinePathTracer", {'useScreenSpaceReSTIR': False, 'colorFormat': ColorFormat.RGBA32F})
    g.addPass(InlinePathTracerReference, "InlinePathTracerReference")
    AccumulatePass = createPass("AccumulatePass", {'enabled': True, 'precisionMode': AccumulatePrecision.Single, 'maxAccumulatedFrames': 2 ** 16})
    g.addPass(AccumulatePass, "AccumulatePass")
    ToneMappingPassReference = createPass("ToneMapper", {'autoExposure': False, 'exposureCompensation': 0.0})
    g.addPass(ToneMappingPassReference, "ToneMappingPassReference")

    g.addEdge("GBufferRT.vbuffer",                              "InlinePathTracerReference.vbuffer")
    g.addEdge("InlinePathTracerReference.color",                "AccumulatePass.input")
    g.addEdge("AccumulatePass.output",                          "ToneMappingPassReference.src")


    ######################################################################################################
    ########## Test graph (NRD/ReLAX and DLSS on top of inline path tracer + ReSTIR results) #############
    ##########       NOTE: This graph can be replaced with your own rendering setup          #############
    ######################################################################################################
    InlinePathTracerTest = createPass("InlinePathTracer", {'samplesPerPixel': 1, 'useScreenSpaceReSTIR': True, 'colorFormat': ColorFormat.RGBA32F})
    g.addPass(InlinePathTracerTest, "InlinePathTracerTest")
    ToneMappingPass = createPass("ToneMapper", {'autoExposure': False, 'exposureCompensation': 0.0})
    g.addPass(ToneMappingPass, "ToneMappingPass")
    NRD = createPass("NRD")
    g.addPass(NRD, "NRD")
    ModulateIllumination = createPass("ModulateIllumination")
    g.addPass(ModulateIllumination, "ModulateIllumination")
    DLSS = createPass("DLSSPass", {'motionVectorScale': DLSSMotionVectorScale.Relative, 'isHDR': False})
    g.addPass(DLSS, "DLSS")

    g.addEdge("GBufferRT.vbuffer",                              "InlinePathTracerTest.vbuffer")

    g.addEdge("InlinePathTracerTest.relaxSpecularIllumination", "NRD.SpecularIlluminationAndHitT")
    g.addEdge("InlinePathTracerTest.relaxDiffuseIllumination",  "NRD.DiffuseIlluminationAndHitT")
    g.addEdge("GBufferRT.mvecW",                                "NRD.WorldMotionVectors")
    g.addEdge("GBufferRT.normWRoughness",                       "NRD.WorldNormalAndRoughness")
    g.addEdge("GBufferRT.linearZ",                              "NRD.LinearZ")

    g.addEdge("InlinePathTracerTest.relaxEmission",             "ModulateIllumination.Emission")
    g.addEdge("InlinePathTracerTest.relaxDiffuseReflectance",   "ModulateIllumination.DiffuseReflectance")
    g.addEdge("InlinePathTracerTest.relaxSpecularReflectance",  "ModulateIllumination.SpecularReflectance")
    g.addEdge("NRD.FilteredDiffuseIllumination",                "ModulateIllumination.DiffuseIllumination")
    g.addEdge("NRD.FilteredSpecularIllumination",               "ModulateIllumination.SpecularIllumination")
    g.addEdge("ModulateIllumination.Output",                    "ToneMappingPass.src")

    g.addEdge("GBufferRT.mvec",                                 "DLSS.mvec")
    g.addEdge("GBufferRT.linearZ",                              "DLSS.depth")
    g.addEdge("ToneMappingPass.dst",                            "DLSS.color")

    ######################################################################################################
    ################ Plug reference and test streams into FLIP pass (invoking LDR-FLIP) ##################
    ######################################################################################################
    FLIPPass = createPass('FLIPPass', {'enabled': True, 'isHDR': False, 'useMagma': True, 'monitorWidthPixels': 3840, 'monitorWidthMeters': 0.7, 'monitorDistanceMeters': 0.7, 'computePooledFLIPValues': False, 'useRealMonitorInfo': False})
    g.addPass(FLIPPass, 'FLIPPass')
    g.addEdge('DLSS.output', 'FLIPPass.testImage') # NOTE: Input to LDR-FLIP must have low dynamic range (and be in [0, 1] range). This is achieved with standard tone mappers.
    g.addEdge('ToneMappingPassReference.dst', 'FLIPPass.referenceImage') # NOTE: Input to LDR-FLIP must have low dynamic range (and be in [0, 1] range). This is achieved with standard tone mappers.

    g.markOutput('FLIPPass.errorMapDisplay')
    g.markOutput("DLSS.output")
    g.markOutput("ToneMappingPassReference.dst")
    g.markOutput("InlinePathTracerTest.color")
    return g

m.loadScene('TestScenes/MaterialTest.pyscene')

LDRFLIPDemo = render_graph_LDRFLIPDemo()
try: m.addGraph(LDRFLIPDemo)
except NameError: None